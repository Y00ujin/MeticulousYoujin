## 4.5 세그웨이를 이용한 화면 전환

##### 세그웨이라고 불리는 객체는 스토리보드에서 뷰 컨트롤러 사이의 연결 관계 및 화면 전환을 관리하는 역할을 합니다. 세그웨이는 화면과 화면을 연결하기 위해 아무런 소스 코드도 필요로 하지 않는다는 특징이 있는데, 뷰 컨트롤러와 뷰 컨트롤러 또는 화면 전환의 매개체가 되는 버튼과 뷰 컨트롤러 사이를 직접 연결하는 식으로 화면 전환 관계를 구성합니다.

##### 스토리보드상에서 세그웨이는 뷰 컨트롤러 사이에 연결된 화살표로 표시됩니다. 이 화살표는 한 쪽 방향으로 향하는 모습을 하고 있는데, 이는 출발지와 목적지가 있다는 뜻입니다. 

##### 세그웨이를 이용하면 뷰 컨트롤러의 객체를 생성할 필요가 없습니다. 세그웨이가 스토리보드상의 연결 정보를 이용하여 대상 뷰 컨트롤러의 인스턴스를 자동으로 만들어주기 때문입니다. 세그웨이가 실행되는 순간 스토리보드를 통하여 이미 세그웨이의 출발지와 목적지 뷰 컨트롤러에 대한 인스턴스가 생성되고, 그 포인터가 세그웨이 객체에 설정됩니다. 따라서 해야 할 일은 단지 화면 전환을 위해 필요한 세그웨이를 찾아 실행하는 것뿐입니다.

##### 출발점이 뷰 컨트롤러 자체인 경우를 메뉴얼 세그웨이, 버튼, 테이블 셀 등이 출발점인 경우를 액션 세그웨이 또는 트리거 세그웨이라고 나누어 부르기도 합니다. 그러나 이 구분은 세그웨이를 실행하는 방식에서만 차이가 있을 뿐, 두 가지 방식 모두 세그웨이를 실행하기만 하면 화면 전환이 이루어진다는 점에서 공통입니다.

##### 메뉴얼 세그웨이를 실행하려면 UIKit 프레임워크에 정의된 `performSegue(withIdentifier:sender:)` 메소드를 사용합니다. 반면 액션 세그웨이는 버튼의 터치 이벤트가 세그웨이 실행으로 바로 연결되므로, 소스 코드를 추가하지 않아도 화면 전환 기능을 구현할 수 있습니다.

<br>
<br>
<br>

## 4.5.1 액션 세그웨이
##### 액션 세그웨이는 트리거와 세그웨이가 직접 연결된 것을 의미합니다. 트리거란 터치 또는 클릭 이벤트를 발생시켜 세그웨이를 실행할 수 있는 요소를 말합니다. 

##### 액션 세그웨이는 화면 전환을 위해 프로그래밍 코드가 일절 필요하지 않을 뿐만 아니라, 스토리보드에 구현된 객체를 트리거로 지정하기만하면 되므로 전체적인 구성이 굉장히 단순해진다는 장점이 있습니다.

##### 세그웨이 연결 옵션 중에서 선택한 [Present Modally] 항목은 우리가 앞서 학습했던 화면 전환 메소드 중 present(_:animated:) 메소드를 이용한 화면 전환과 같은 기능을 합니다. 즉, 뷰 컨트롤러 자신이 새로운 화면을 불러들이도록 처리하는 거죠. 

##### 세그웨이 연결 옵션 중에서 [Show] 를 선책하면 내비게이션 컨트롤러를 통한 화면 이동이 발생합니다. 반면 [Present Modally] 타입으로 생성한 세그웨이는 프레젠트 메소드를 통하여 화면 이동한 것과 같습니다. 이때는 설령 내비게이션 컨트롤러가 추가되어 있더라도 이를 사용하지 않고 직접 화면을 이동하기 때문에 네비게이션 바가 추가되지 않습니다.

##### 네비게이션 컨트롤러를 추가하지 않고 세그웨이를 [show] 타입으로 생성하면 [show] 타입으로 생성했다고 하더라도 [Present Modally] 방식으로 실행됩니다.

##### 네비게이션 컨트롤러와 첫번째 루트 뷰 컨트롤러를 다시 연결할 때에는 세그웨이를 연결하듯이 양쪽으로 마우스 우클릭 드래그로 연결한 후 [root view controller] 타입을 선택하면 됩니다. 

<br>
<br>
<br>

## 4.5.2 메뉴얼 세그웨이
##### 메뉴얼 세그웨이는 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 수동 실행 세그웨이 입니다. 액션 세그웨이는 트리거의 터치에 의해 실행되므로 별도의 처리 코드가 전혀 필요 없지만, 메뉴얼 세그웨이는 트리거 없이 수동으로 실행해야 하므로 소스 코드에서 세그웨이를 실행할 메소드를 호출해야 합니다. 매뉴얼 세그웨이를 실행하기 위한 메소드는 다음과 같습니다.
```Swift
performSeque(withIdentifier : <세그웨이 식별자>, sender: <세그웨이 실행 객체>)
```

##### 출발지 뷰 컨트롤러의 도크 중 첫번째 아이콘을 클릭하여 두번째 뷰 컨트롤러로 ctrl + 드래그 합니다. 이어서 표시되는 세그웨이 타입 선택 창에서는 [Manual Segue] -> [Present Modally]를 선택합니다.

##### 추가된 메뉴얼 세그웨이를 메소드에서 호출하려면 세그웨이에 식별자를 부여해야 합니다. 세그웨이를 선택하고 어트리뷰트 인스펙터 탭을 열면 [Identifier] 항목에 'ManualWind'라고 입력합니다. 여기서 입력하는 값은 잠시 후 소스 코드에서 메소드의 인자값으로 사용하게 됩니다.

##### 이제 버튼을 소스코드와 연결하고 추가된 @IBAction 메소드 내부에 다음과 같이 코드를 작성합니다.
```Swift
self.performSeque(withIdentifier:"ManualWind", sender: self)
```

<br>

##### 화면전환 효과는 세그웨이를 클릭한 후 어트리뷰트 인스펙터 탭을 열어 [Transition] 항목에서 변경할 수 있습니다.

<br>
<br>
<br>

## 4.5.3 Unwind - 화면 복귀
##### 새로운 화면으로 전환하는 것을 wind라고 한다면 Unwind는 Wind 작업을 해제한다는 의미라고 볼 수 있습니다. 다시 말해, 새로운 화면을 해제하고 본래의 화면으로 돌아간다는 해석이 되는 셈입니다.

##### Unwind를 처리하는 방법은 이전에 배웠던 화면 복귀용 메소드를 이용하는 방법이 있습니다.
- ##### 프레젠테이션 방식으로 이동했을 때 : `dismiss(animated:)`
- ##### 네비게이션 컨트롤러를 이용하여 이동했을 때 : `popViewController(animated:)`

<br>

##### 또 다른 방법은 세그웨이 구조에서 제공하는 Unwind Segue를 사용하는 것 입니다. A 에서 B로 화면 전환을 했다고 했을 때, B에서 A로 Unwind 하기 위해서는 일단 A 에 아래와 같은 @IBAction 메소드를 추가합니다. 이 메소드는 ㅏㅂㄴ드시 UIStoryboardSegue 타입의 인자값을 가지도록 정의해야 합니다.
```Swift
@IBAction func unwindToVC(_ segue: UIStoryboardSegue) {

}
```

<br>

##### 그후 B에 존재하는 버튼을 상단 도크의 마지막 Exit 아이콘으로 연결하고 이어서 표시되는 우리가 A에 추가한 unwindToVC: 메소드를 선택해줍니다. 그럼 B의 버튼을 클릭했을 때 Unwind 할 수 있습니다.

<br>
<br>

### Unwind Segue를 이용하여 한꺼번에 여러 페이지 복귀하기
##### 네비게이션 컨트롤러를 추가한 후 root view controller의 네비게이션 바의 오른쪽에 위치한 버튼을 클릭할 시 새로운 view controller로 show타입의 segue를 이용하여 화면전환 되도록 합니다. 이 과정을 반복하여 page3, 4까지의 뷰 컨트롤러를 추가하고 세그웨이로 연결합니다. 

##### 제일 마지막에 위치한 page 4의 네비게이션 바에 바 버튼을 추가하겠습니다. 이 버튼은 맨 첫 화면으로 돌아가는 역할을 하게 됩니다.

##### 먼저 page 1 root view controller에 Unwind 메소드를 생성합니다.
```Swift
@IBAction func gotoPage1(_sender: UIStoryboardSegue){

}
```

<Br>

##### 그후 스토리보드로 돌아가 page 4의 도크의 세번째 아이콘에 네비게이션 바의 바 버튼을 Ctrl + 드래그 하여 goToPage1 메소드를 선택합니다.

##### 이렇게 하면 연결된 세그웨이를 따라 화면어 page 1 -> page 2 -> page 3 -> page 4로 이동합니다. 이와 함께 뷰 컨트롤러의 인스턴스는 차례로 네비게이션 스택에 쌓이죠. 맨 마지막 Page 4에서 Home 버튼을 클릭하여 Unwind Segue를 실행하면 Page 1이 화면에 나타나면서 내비게이션 스택의 중간에 쌓여있던 page2, page3의 인스턴스는 메모리에서 모두 해제됩니다. dealloc 된다고 표현하죠. 이와같은 Unwind Segue는 프레젠테이션 방식이나 네비게이션 컨트롤러를 이용한 방식에 구분 없이 실행되는 것이 특징입니다.

<br>
<Br>

### 중간 페이지로 돌아가기
##### 중간 페이지로 돌아가는 것도 방금 구현한 것과 똑같은 방식입니다. 돌아가고자 하는 뷰 컨트롤러에 이정표 역할을 하는 메소드를 만들어 준 다음, Exit 아이콘을 통해 버튼과 연결하면 됩니다.

<br>
<br>
<br>

## 4.5.4 커스텀 세그웨이
##### UIKit 프레임워크는 UIStoryboardSegue 클래스를 서브클래싱하여 새로운 기능을 갖춘 세그웨이 객체를 정의할 수 있도록 지원합니다. 이를 커스텀 세그웨이라고 부릅니다.

##### 커스텀 세그웨이를 만들 것이기 때문에 UIStoryboardSegue 클래스를 상속받는 클래스를 작성해야 합니다. NewSegue.swift 파일을 생성하고 다음과 같이 클래스를 작성합니다.
```Swift
import UIKit

class NewSegue: UIStoryboardSegue {

}
```

<br>

##### UIStoryboardSegue 클래스에서 세그웨이의 실행을 처리하는 메소드는 perform()이기 때문에 커스텀 세그웨이에서도 원하는 화면 전환 기능을 구현하기 위해서는 perform() 메소드를 오버라이드해야 합니다. NewSegue 클래스에 perform() 메소드를 다음과 같이 오버라이드 합니다.
```Swift
import UIKit

class NewSegue: UIStoryboardSegue{

    override func perform(){
        // 세그웨이의 출발지 뷰 컨트롤러
        let srcUVC = self.source

        // 세그웨이의 목적지 뷰 컨트롤러
        let destUVC = self.destination

        // fromView에서 toView로 뷰를 전환한다
        UIView.transition(from: stcUVC.view,
                        to: destUVC.view,
                        duration: 2,
                        options: ,transitionCurlDown)
    }
}
```

#####  세그웨이는 양쪽 뷰 컨트롤러 사이를 한쪽 방향으로 연결하는 객체이기 때문에 항상 출발지와 목적지에 해당하는 뷰 컨트롤러를 가집니다. 이들 각각은 self.source, self.destination 속성을 사용하여 읽어올 수 있습니다. 읽어온 속성의 타입은 UIViewController입니다.

##### 이제 이를 이용하여 양쪽 사이의 화면 전환 방식을 정의해주면 됩니다. 각자 구현하는 커스텀 세그에 따라 전환 방식은 모두 달라지는데, 예제에서 구현하고 있는 것은 UIView 객체의 전환 기능을 사용하는 방법입니다.
```Swift
UIView.transition(from:to:duration:options:)
```
<br>

##### transition()은 타입 메소드기 때문에 UIView 클래스의 인스턴스를 생성하지 않고도 호출할 수 있습니다. 이 메소드는 모두 네 개의 인자값을 가지는데, 각각 다음과 같습니다.
```Swift
        UIView.transition(from: <출발지 뷰>,
                        to: <목적지 뷰>,
                        duration: <화면 전환에 소요되는 시간(단위:초)>,
                        options: <애니메이션 전환 옵션>)
```

<br>

##### 만약 화면 전환이 끝난 후에 뭔가 처리할 내용이 있다면, completion 매개변수가 추가되어 있는 메소드를 사용하면 됩니다.
```Swift
        UIView.transition(from: <출발지 뷰>,
                        to: <목적지 뷰>,
                        duration: <화면 전환에 소요되는 시간(단위:초)>,
                        options: <애니메이션 전환 옵션>),
                        completion: <화면 전환이 끝난 후 실행할 함수나 클로저 구문>
```

<br>

##### 현재 우리가 구현하고자 하는 커스텀 세그웨이는 화면 전환 시 뷰 컨트롤러 전체를 전환하는 대신, 다른 컨트롤러에 있는 뷰만 읽어와 전환하는 세그웨이 입니다. 이를 응용하면 뷰 컨트롤러에 하나에서 상태값에 따라 여러 가지 다른 뷰를 다양하게 표현하는 일이 가능합니다. 

##### 이렇게 뷰를 컨트롤하는 방법도 있지만, 이렇게 하면 하나의 뷰 컨트롤러가 두 개 이상의 루트 뷰를 모두 제어해야 하므로 그리 좋은 구조가 아닙니다. 가급적 하나의 뷰 컨트롤러는 하나의 루트 뷰만 제어하는 것이 좋습니다.

##### 이렇게 커스텀 클래스가 완성되었습니다. 이를 세그웨이에 적용해봅시다.

##### 스토리보드를 열거 두 개의 뷰 컨트롤러를 준비합니다. 첫번째 뷰컨트롤러에 버튼을 추가하고 이것을 두번재 뷰 컨트롤러로 드래그하여 액션 세그웨이를 연결합니다. 이때 액션 세그웨이의 여러 타입 중에서 우리가 선택해야하는 것은 Custom입니다.

##### 연결된 세그웨이를 클릭하여 활성화 한 다음, 어트리뷰트 인스펙터 탭을 오픈하여 [Class] 항목에 우리가 작성한 NewSegue를 선택합니다. 그럼 설정한대로 화면전환 되는 것을 확인할 수 있습니다.


<br>
<br>
<br>

## 4.5.5 전처리 메소드의 활용
##### 프로그래밍 코드를 통해 화면을 전환하는 방식은 구현하기 어렵고 상대적으로 난이도가 높지만 화면 전환 과정을 직접 제어할 수 있기 때문에 자유도가 높습니다. 반면에 세그웨이를 이용하여 화면을 전환하는 방식은 구현이 쉽고 간단하긴 하지만, 화면 전환 과정에서 우리가 제어할 수 있는 자유도가 제한되는 단점이 있습니다.

##### 세그웨이를 이용하여 화면을 전환하는 과정에서 뭔가 특별한 처리를 해 주어야 할 때에는 어떻게 할까요? 코코아 터치 프레임워크는 세그웨이가 실행되기 전에 특정한 메소드를 호출하도록 설계되어 있기 때문에, 이를 활용하면 화면을 전환하기 전에 필요한 처리를 해 줄 수 있습니다. 이를 전처리 메소드라고 합니다. 전처리 메소드에 원하는 내용을 작성해 높으면 그 내용이 세그웨이가 실행되기 전에 자동으로 실행됩니다. 세그웨이를 실행하기 전, 준비 작업의 의미로 실행되는 전처리 메소드의 정체는 다음과 같습니다.
```Swift
    prepare(for segue: UIStoryboardSegue, sender: Any?){}
```

<br>

##### 이 메소드의 호출 주체는 우리가 아닙니다. 시스템이 호출합니다. 이 메소드의 첫번째 매개변수는 메소드를 호출한 세그웨이 객체입니다. 세그웨이는 여러개일 수 있는데 이들은 모두 실행 전에 공통적으로 전처리 메소드를 호출합니다. 하나의 전처리 메소드를 여러 세그웨이가 공유하는 방식입니다. 메소드 내에서 첫번째 매개변수를 사용하여 세그웨이에 따른 조건별 작업을 처리하면 됩니다.

##### 두 번째 매개변수는 세그웨이를 실행하는 트리거에 대한 정보입니다. 하나의 뷰 컨트롤러가 여러개의 세그웨이를 가질 수 있는 것처럼 하나의 세그웨이는 여러 개의 트리거를 가질 수 있습니다. 화면 내에 있는 여러 요소가 동일한 세그웨이를 실행할 수 있다는 뜻 입니다. 따라서 어느 객체가 트리거 역할을 했는지 종종 알아야 할 때가 있는데 이에 대한 정보가 두 번째 매개변수를 통해 전달됩니다. 액션 세그웨이라면 버튼이나 테이블 셀, 혹은 제스처 등의 객체가 주 대상이 될 것이고, 매뉴얼 세그웨이라면 뷰 컨트롤러 자신이 인자값으로 전달될 겁니다.

##### 전처리 메소드는 UIViewController 클래스에 이미 정의되어 있으므로 오버라이드 하여 사용합니다. 전처리 메소드 호출 시 필요한 인자값은 메소드를 호출하는 iOS 시스템이 알아서 채워 넣어주므로, 우리는 이 인자값을 받아 사용하기만 하면 됩니다.

<br>

##### 이제 실제로 전처리 메소드를 사용해봅시다. NSLog는 파운데이션 프레임워크에서 정의된 클래스로 입력된 문자열을 Xcode의 디버그 콘솔에 출력하는 기능을 합니다. 프로그래밍 과정에서 직접적인 처리 내용과는 관련이 없지만 프로세스의 흐름을 살펴보기 쉽도록 출력하는 메시지를 로그라고 하는데, 주로 값을 확인하는 용도나 실행 과정에서 발생하는 여러 과정을 체크하는 용도로 많이 사용됩니다.
<p align="center"> 
<img width="696" alt="스크린샷 2022-07-28 오후 4 14 18" src="https://user-images.githubusercontent.com/71479613/181444077-51d3d13e-37b9-4e82-999d-2e407a6b4db2.png">
<p align="center">

<br>

##### 액션 세그웨이의 Identifier 항목의 값을 action_segue로 입력한 후 prepare 메소드 내에서 실행되는 세그웨이의 아이디를 출력하도록 하겠습니다. 이 첫번째 매개변수를 활용하여 세그웨이 별로 처리할 수 있습니다.
```Swift
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    NSLog(segue.identifier!)
}
```